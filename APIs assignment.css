<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScholarSync - Academic Paper Finder</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- Custom Styles --- */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .container {
            max-width: 1000px;
        }
        /* Card hover effect for better user experience */
        .card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }
        .sort-icon {
            cursor: pointer;
            margin-left: 0.5rem;
            opacity: 0.6;
        }
        /* Custom Scrollbar for Filter Column */
        #source-filters::-webkit-scrollbar {
            width: 6px;
        }
        #source-filters::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #source-filters::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #source-filters::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Ensure the link text truncation works visually */
        .card h2 a {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="container mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-blue-800">ScholarSync</h1>
            <p class="text-gray-600 mt-2">Find and filter up-to-date academic research.</p>
        </header>

        <!-- Search Input -->
        <div class="bg-white p-6 rounded-xl card mb-8 shadow-lg">
            <form id="search-form" class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="search-query" placeholder="Enter keywords (e.g., 'quantum computing applications')"
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" required>
                <button type="submit" id="search-button"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-150 ease-in-out shadow-md disabled:opacity-50">
                    <span id="button-text">Search Papers</span>
                    <svg id="loading-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </button>
            </form>
        </div>

        <!-- Filter and Results Section -->
        <div id="results-container" class="grid grid-cols-1 lg:grid-cols-4 gap-6">

            <!-- Filters Column (Hidden until results are available) -->
            <div id="filter-column" class="lg:col-span-1 bg-white p-6 rounded-xl card hidden">
                <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Filter Results</h3>
                
                <!-- Filter by Source/Journal -->
                <div class="mb-6">
                    <label class="block text-gray-700 font-semibold mb-2">Source / Journal</label>
                    <div id="source-filters" class="space-y-2 max-h-40 overflow-y-auto pr-2">
                        <!-- Checkboxes will be inserted here -->
                        <p class="text-sm text-gray-500">Search to populate filters.</p>
                    </div>
                </div>

                <!-- Sorting (Only by Citation/Relevance is practical here) -->
                <div>
                    <label class="block text-gray-700 font-semibold mb-2">Sort By</label>
                    <select id="sort-select" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-white" disabled>
                        <option value="relevance" data-order="desc">Relevance (Default)</option>
                        <option value="citation_count" data-order="desc">Citation Count (High to Low)</option>
                        <option value="citation_count" data-order="asc">Citation Count (Low to High)</option>
                    </select>
                </div>
            </div>

            <!-- Results Column -->
            <div id="paper-results" class="lg:col-span-3">
                <div class="bg-white p-6 rounded-xl text-center shadow-lg">
                    <p class="text-gray-500" id="initial-message">Enter a topic above to start searching for academic papers.</p>
                    <div id="error-message" class="text-red-600 font-bold hidden"></div>
                    <div id="no-results-message" class="hidden">
                        <h4 class="text-2xl font-semibold text-gray-700 mt-4">No Papers Found</h4>
                        <p class="text-gray-500 mt-2">Try broadening your search terms or checking your spelling.</p>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // Import necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Ensure firebase config is valid
        if (Object.keys(firebaseConfig).length === 0) {
            console.error("Firebase configuration is missing or invalid.");
            document.getElementById('error-message').textContent = "Application Error: Firebase configuration not loaded.";
            document.getElementById('error-message').classList.remove('hidden');
        }

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // Log levels for debugging
        setLogLevel('debug');

        let isAuthReady = false;
        let currentUserId = null;
        let papersData = []; // Store the full, original fetched data
        let currentFilters = new Set(); // Store active source filters
        let currentSort = { key: 'relevance', order: 'desc' }; // Store current sort state

        // DOM elements
        const form = document.getElementById('search-form');
        const queryInput = document.getElementById('search-query');
        const resultsDiv = document.getElementById('paper-results');
        const initialMessage = document.getElementById('initial-message');
        const errorMessage = document.getElementById('error-message');
        const noResultsMessage = document.getElementById('no-results-message');
        const searchButton = document.getElementById('search-button');
        const buttonText = document.getElementById('button-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const filterColumn = document.getElementById('filter-column');
        const sourceFiltersDiv = document.getElementById('source-filters');
        const sortSelect = document.getElementById('sort-select');

        // --- Firebase Authentication Setup ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                console.log("User signed in with UID:", currentUserId);
            } else {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously.");
                    }
                } catch (error) {
                    console.error("Authentication failed:", error);
                    errorMessage.textContent = `Authentication failed: ${error.message}`;
                    errorMessage.classList.remove('hidden');
                }
            }
            isAuthReady = true;
        });
        
        // --- Utility Functions for Data Handling ---
        
        /**
         * Cleans up the raw text response from the LLM into a structured list of paper objects.
         * Since the LLM returns unstructured text, this is a heuristic parsing step.
         * @param {string} text The raw text output from the Gemini API.
         * @param {Array<Object>} sources The grounding attributions (sources).
         * @returns {Array<Object>} Structured array of paper objects.
         */
        function parsePapersFromText(text, sources) {
            // Split the text by double newlines or similar separators to get individual paper blocks
            const blocks = text.split(/\n\s*\n/).filter(b => b.trim().length > 0);
            const paperList = [];

            // A heuristic approach: assume the first paragraph of each block is the title, 
            // the second sentence is the author/year, and the rest is the abstract.
            blocks.forEach((block, index) => {
                const lines = block.trim().split('\n').filter(l => l.trim().length > 0);
                const title = lines[0] || `Paper ${index + 1}`;
                const abstract = lines.slice(1).join(' ').substring(0, 300) + '...'; // Truncate abstract
                
                // Mock metadata (since the LLM only gives text content)
                const mockMetadata = {
                    authors: 'AI Synthesis',
                    year: new Date().getFullYear(),
                    citation_count: Math.floor(Math.random() * 500) + 50 // Simulate citation count
                };

                // Link the paper to the grounding source for a "Source/Journal"
                const source = sources[index % sources.length] || { title: 'General Academic Source', uri: '#' };
                
                paperList.push({
                    id: crypto.randomUUID(),
                    title: title.replace(/^\*\*/, '').replace(/\*\*$/, '').trim(), // Clean up potential markdown
                    abstract: abstract.trim(),
                    authors: mockMetadata.authors,
                    year: mockMetadata.year,
                    citation_count: mockMetadata.citation_count,
                    source_title: source.title,
                    source_uri: source.uri,
                    relevance: blocks.length - index, // Higher relevance for papers appearing earlier
                });
            });

            return paperList;
        }

        /**
         * Renders the current papers data based on active filters and sort order.
         * @param {Array<Object>} data The filtered and sorted array of paper objects.
         */
        function renderPapers(data) {
            resultsDiv.innerHTML = ''; // Clear previous results

            if (data.length === 0) {
                noResultsMessage.classList.remove('hidden');
                return;
            } else {
                noResultsMessage.classList.add('hidden');
            }

            data.forEach(paper => {
                const cardHtml = `
                    <div class="bg-white p-6 rounded-xl card mb-4 border-l-4 border-blue-500">
                        <h2 class="text-xl font-bold text-gray-900 mb-2 hover:text-blue-600 transition duration-150">
                            <a href="${paper.source_uri}" target="_blank" rel="noopener noreferrer">${paper.title}</a>
                        </h2>
                        <div class="text-sm text-gray-500 mb-3 space-x-4">
                            <span><strong>Authors:</strong> ${paper.authors}</span>
                            <span><strong>Year:</strong> ${paper.year}</span>
                            <span><strong>Citations:</strong> <span class="text-green-600 font-semibold">${paper.citation_count}</span></span>
                        </div>
                        <p class="text-gray-700 mb-4 text-justify">${paper.abstract}</p>
                        <div class="flex justify-between items-center text-xs">
                            <span class="bg-gray-200 text-gray-700 px-3 py-1 rounded-full font-medium">Source: ${paper.source_title}</span>
                            <a href="${paper.source_uri}" target="_blank" rel="noopener noreferrer" class="text-blue-500 hover:text-blue-700 font-medium">Read More &rarr;</a>
                        </div>
                    </div>
                `;
                resultsDiv.insertAdjacentHTML('beforeend', cardHtml);
            });
        }
        
        /**
         * Populates the filter sidebar with checkboxes based on unique sources.
         * @param {Array<Object>} data The full array of paper objects.
         */
        function populateFilters(data) {
            const uniqueSources = [...new Set(data.map(p => p.source_title))].sort();
            sourceFiltersDiv.innerHTML = '';
            
            if (uniqueSources.length === 0) {
                 sourceFiltersDiv.innerHTML = '<p class="text-sm text-gray-500">No external sources identified.</p>';
            } else {
                uniqueSources.forEach(source => {
                    const isChecked = currentFilters.has(source);
                    const count = data.filter(p => p.source_title === source).length;
                    
                    const filterHtml = `
                        <label class="inline-flex items-center text-gray-700 cursor-pointer hover:bg-gray-100 p-1 rounded w-full">
                            <input type="checkbox" data-source="${source}" ${isChecked ? 'checked' : ''} 
                                   class="form-checkbox h-4 w-4 text-blue-600 rounded" onchange="filterResults(event.target.dataset.source, this.checked)">
                            <span class="ml-2 text-sm">${source} (${count})</span>
                        </label>
                    `;
                    sourceFiltersDiv.insertAdjacentHTML('beforeend', filterHtml);
                });
            }
            filterColumn.classList.remove('hidden');
            sortSelect.disabled = false;
        }

        /**
         * Filters and sorts the global papersData array.
         */
        function applyFiltersAndSort() {
            let filteredData = papersData;

            // 1. Apply Filtering
            if (currentFilters.size > 0) {
                filteredData = papersData.filter(paper => currentFilters.has(paper.source_title));
            }

            // 2. Apply Sorting
            filteredData.sort((a, b) => {
                const key = currentSort.key;
                const order = currentSort.order === 'asc' ? 1 : -1;
                
                if (key === 'relevance') {
                    // Relevance is defined by the original fetch order
                    return order * (a.relevance - b.relevance);
                } else if (key === 'citation_count') {
                    return order * (a.citation_count - b.citation_count);
                }
                return 0;
            });

            renderPapers(filteredData);
        }

        // Expose global function for filter change event
        window.filterResults = (source, isChecked) => {
            if (isChecked) {
                currentFilters.add(source);
            } else {
                currentFilters.delete(source);
            }
            applyFiltersAndSort();
        };

        // Event listener for sorting change
        sortSelect.addEventListener('change', (e) => {
            const selectedOption = e.target.options[e.target.selectedIndex];
            currentSort.key = selectedOption.value;
            currentSort.order = selectedOption.dataset.order;
            applyFiltersAndSort();
        });

        // --- API Interaction Logic (Simulating Backend Proxy) ---
        
        const MAX_RETRIES = 3;
        const BASE_DELAY = 1000;
        
        async function fetchAcademicPapers(query) {
            if (!isAuthReady) {
                throw new Error("Authentication not ready. Please wait and try again.");
            }

            const systemPrompt = "You are an AI assistant designed to act as an Academic Paper Finder. Based on the user's query, find and synthesize the titles, authors, and a brief abstract for three highly relevant academic papers or research findings. Format your response as a single, readable string, clearly separating each entry with an empty line. Do not use Markdown formatting like lists or headers in the output text. Use mock values for citation counts and year if not found.";
            
            const userQuery = `Find academic papers, research articles, or recent scientific findings about: "${query}"`;
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title || 'Unknown Source',
                                }))
                                .filter(source => source.uri && source.title);
                        }

                        if (text.length < 50) { // Check for minimal content
                            throw new Error("Generated content was too brief or irrelevant.");
                        }

                        return { text, sources };
                    } else {
                        throw new Error("API response lacked candidate text.");
                    }
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error.message);
                    if (i === MAX_RETRIES - 1) {
                        throw new Error(`Failed to fetch papers after ${MAX_RETRIES} attempts. Network or API issue.`);
                    }
                    // Exponential backoff
                    const delay = BASE_DELAY * Math.pow(2, i);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        // --- Event Handlers ---
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const query = queryInput.value.trim();
            if (!query) return;

            // Reset UI state
            initialMessage.classList.add('hidden');
            errorMessage.classList.add('hidden');
            noResultsMessage.classList.add('hidden');
            
            // Set Loading State
            buttonText.textContent = "Searching...";
            loadingSpinner.classList.remove('hidden');
            searchButton.disabled = true;
            resultsDiv.innerHTML = '<div class="text-center p-8 text-gray-500">Retrieving papers...</div>';
            
            // Clear previous filters/sort
            papersData = [];
            currentFilters.clear();
            
            try {
                const { text, sources } = await fetchAcademicPapers(query);
                
                // Parse and store data
                papersData = parsePapersFromText(text, sources);

                if (papersData.length === 0) {
                    noResultsMessage.classList.remove('hidden');
                    filterColumn.classList.add('hidden');
                } else {
                    // Initial rendering, filtering, and sorting
                    applyFiltersAndSort(); 
                    populateFilters(papersData);
                }

            } catch (error) {
                console.error("Search failed:", error);
                // Clear any results and show error
                resultsDiv.innerHTML = ''; 
                errorMessage.textContent = `Error: ${error.message}`;
                errorMessage.classList.remove('hidden');
                filterColumn.classList.add('hidden');
                
            } finally {
                // Reset Button State
                buttonText.textContent = "Search Papers";
                loadingSpinner.classList.add('hidden');
                searchButton.disabled = false;
            }
        });

        // Initial setup for the sort selector
        sortSelect.value = 'relevance';
    </script>
</body>
</html>